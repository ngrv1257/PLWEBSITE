<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Font Converter ‚Äì Unicode ‚áÑ Amar</title>

<!-- DOCX handling from browser -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #f3f3f3;
    margin: 0;
    padding: 0;
  }
  .container {
    max-width: 960px;
    margin: 20px auto;
    background: #fff;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
  }
  h2 {
    text-align: center;
    margin-bottom: 10px;
  }
  textarea {
    width: 100%;
    min-height: 140px;
    font-size: 16px;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #ccc;
    resize: vertical;
  }
  .btn-row {
    margin: 10px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }
  button {
    flex: 1;
    min-width: 140px;
    padding: 10px 16px;
    border-radius: 8px;
    border: none;
    background: #111;
    color: #fff;
    font-size: 15px;
    cursor: pointer;
  }
  button:hover {
    background: #333;
  }
  hr {
    margin: 24px 0;
  }
  @media (max-width: 600px) {
    button { flex: 100%; }
  }
</style>
</head>



<!-- ===================== PASSWORD SECURITY SCREEN ===================== -->



<style>
  /* Dark overlay */
  #lockScreen {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.72);
    backdrop-filter: blur(8px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  /* Main box */
  #lockBox {
    background: #111;
    color: white;
    width: 420px;
    max-width: 90%;
    padding: 32px;
    border-radius: 18px;
    text-align: center;
    box-shadow: 0 0 32px rgba(0,0,0,0.4);
    animation: fadeIn 0.4s ease;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(-12px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  #lockBox h2 {
    margin-top: 0;
    font-size: 26px;
  }

  #attemptInfo {
    margin: 10px 0 18px;
    font-size: 14px;
    opacity: 0.8;
  }

  #keyInputBox {
    position: relative;
    width: 100%;
  }

  #securityKey {
    width: 100%;
    padding: 12px 48px 12px 14px;
    border-radius: 8px;
    border: none;
    outline: none;
    font-size: 17px;
    box-sizing: border-box;
  }

  #toggleEye {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 22px;
    cursor: pointer;
    user-select: none;
  }

  #unlockBtn {
    width: 100%;
    margin-top: 22px;
    padding: 12px;
    background: #007bff;
    border: none;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    font-size: 17px;
  }

  #unlockBtn:hover {
    background: #0065d3;
  }
</style>

<div id="lockScreen">
  <div id="lockBox">
    <h2>üîê Enter Security Key</h2>
    <div id="attemptInfo">You have <b>3</b> attempts remaining</div>

    <div id="keyInputBox">
      <input type="password" id="securityKey" placeholder="Enter key‚Ä¶" />
      <span id="toggleEye">üëÅÔ∏è</span>
    </div>

    <button id="unlockBtn">Unlock</button>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {

  const CORRECT_KEY = "N251479@";
  let attempts = 3;

  const lockScreen = document.getElementById("lockScreen");
  const keyInput   = document.getElementById("securityKey");
  const attemptInfo = document.getElementById("attemptInfo");
  const unlockBtn = document.getElementById("unlockBtn");
  const toggleEye = document.getElementById("toggleEye");

  // üëÅ Eye toggle
  toggleEye.onclick = () => {
    keyInput.type = keyInput.type === "text" ? "password" : "text";
  };

  // ‚úÖ AUTO-UNLOCK while typing (NO click needed)
  keyInput.addEventListener("input", () => {
    if (keyInput.value.trim() === CORRECT_KEY) {
      unlock(true);
    }
  });

  // ENTER key
  keyInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") unlock();
  });

  // Button click
  unlockBtn.onclick = () => unlock();

  function unlock(auto = false) {
    const val = keyInput.value.trim();

    if (val === CORRECT_KEY) {
      lockScreen.style.display = "none";
      return;
    }

    if (auto) return; // don't reduce attempts while typing

    attempts--;
    attemptInfo.innerHTML = `You have <b>${attempts}</b> attempts remaining`;
    keyInput.value = "";

    if (attempts <= 0) {
      alert("Access denied. Closing.");
      window.close();
      location.href = "about:blank";
    }
  }

});
</script>



<body>



<div class="container">
  <h2>Font Converter : Unicode ---> Amar</h2>

  <label><b>Unicode Input:</b></label>
  <textarea id="unicodeInput" placeholder="Type or paste Unicode text here..."></textarea>

  <div class="btn-row">
    <button onclick="handleUnicodeToAmar()">Unicode ‚Üí Amar</button>

    <button onclick="copyAmar()">Copy Amar Output</button>
  </div>

  <label><b>Amar Output:</b></label>
  <textarea id="amarOutput" placeholder="Amar Hindi output will appear here..."></textarea>

  <hr>

  <h3>DOCX Upload (Unicode) ‚Üí Amar DOCX Download</h3>
  <input type="file" id="docxFile" accept=".docx" />
  <button onclick="convertDocx()">Convert & Download DOCX</button>
</div>

<script>


/* ============================================================
   PART 1 ‚Äì BASE SIMPLE LETTER MAPPING (MAP_LETTERS)
============================================================ */
const MAP_LETTERS = {
  "‡§ï":"k","‡§ñ":"K","‡§ó":"g","‡§ò":"G","‡§ô":"|",
  "‡§ö":"c","‡§õ":"C","‡§ú":"j","‡§ù":"J","‡§û":"\\",
  "‡§ü":"t","‡§†":"T","‡§°":"f","‡§¢":"F","‡§£":"x",
  "‡§§":"q","‡§•":"Q","‡§¶":"d","‡§ß":"D","‡§®":"n",
  "‡§™":"p","‡§´":"P","‡§¨":"b","‡§≠":"B","‡§Æ":"m",
  "‡§Ø":"X","‡§∞":"r","‡§≤":"l","‡§µ":"v",
  "‡§∂":"S","‡§∑":"‚Ä†","‡§∏":"s","‡§π":"h",

  "‡§Ü":"Aw","‡§Ö":"A","‡§á":"e","‡§à":"e~",
  "‡§â":"a","‡§ä":"‚Äö","‡§è":"E","‡§ê":"Ey","‡§ì":"Ao","‡§î":"AO",

  "‡§Ç":"<","‡§Å":">","‡§æ":"w","‡§ø":"i","‡•Ä":"I","‡•Å":"u","‡•Ç":"U",
  "‡•á":"y","‡•à":"Y","‡•ã":"o","‡•å":"O","‡•É":"√∑",

  "‡•§":"[","‡••":"[[","-":"-","=":"=",
  "‡•¶":"0","‡•ß":"1","‡•®":"2","‡•©":"3","‡•™":"4",
  "‡•´":"5","‡•¨":"6","‡•≠":"7","‡•Æ":"8","‡•Ø":"9",
  "‡§º":"¬°","‡§±":"X¬°"
};

/* ============================================================
   PART 2 ‚Äì HALF-CONSONANTS SET A (MAP_HALFA)
   Used when ANY consonant follows after halant
============================================================ */
const MAP_HALFA = {
  "‡§ï‡•ç":"#","‡§ñ‡•ç":"$","‡§ó‡•ç":"^","‡§ò‡•ç":"%","‡§ô‡•ç":"√ß","‡§ö‡•ç":"√á","‡§õ‡•ç":"C",
  "‡§ú‡•ç":"√à","‡§ù‡•ç":"√â","‡§û‡•ç":"√ä","‡§ü‡•ç":"√®","‡§†‡•ç":"T`","‡§°‡•ç":"√©","‡§¢‡•ç":"F",
  "‡§£‡•ç":"&","‡§§‡•ç":"√ã","‡§•‡•ç":"√å","‡§ß‡•ç":"√ç","‡§®‡•ç":"N","‡§™‡•ç":"√é","‡§∂‡•ç‚Äç":"√ú","‡§∏‡•ç":"√°","‡§∑‡•ç":"√†",
  "‡§´‡•ç":"√è","‡§¨‡•ç":"√ë","‡§Æ‡•ç":"M","‡§≠‡•ç":"√í","‡§≤‡•ç":"√ò","‡§µ‡•ç":"√õ","‡§µ‡•ç":"√õ","‡§µ‡•ç":"√õ","‡§µ‡•ç":"√õ",
  "‡§∞‡•ç":"r`"   // reph form
};

/* ============================================================
   PART 3 ‚Äì HALF-CONSONANTS SET B (MAP_HALFB)
   Used when NO consonant follows after halant
============================================================ */
const MAP_HALFB = {
  "‡§ï‡•ç":"k`","‡§ñ‡•ç":"K`","‡§ó‡•ç":"g`","‡§ò‡•ç":"G`","‡§ô‡•ç":"|`",
  "‡§ö‡•ç":"c`","‡§õ‡•ç":"C`","‡§ú‡•ç":"j`","‡§ù‡•ç":"J`","‡§û‡•ç":"\\`",
  "‡§ü‡•ç":"t`","‡§†‡•ç":"T`","‡§°‡•ç":"f`","‡§¢‡•ç":"F`","‡§£‡•ç":"x`",
  "‡§§‡•ç":"q`","‡§•‡•ç":"Q`","‡§¶‡•ç":"d`","‡§ß‡•ç":"D`","‡§®‡•ç":"n`",
  "‡§™‡•ç":"p`","‡§´‡•ç":"P`","‡§¨‡•ç":"b`","‡§≠‡•ç":"B`","‡§Æ‡•ç":"m`",
  "‡§Ø‡•ç":"X`","‡§∞‡•ç‡§ï‡•ç":"k~`","‡§≤‡•ç":"l`","‡§µ‡•ç":"v`",
  "‡§∂‡•ç":"S`","‡§∑‡•ç":"‚Ä†`","‡§∏‡•ç":"s`","‡§π‡•ç":"h`"
};

/* ============================================================
   PART 4 ‚Äì CONJUNCTS (MAP_CONJ)
   Highest priority after words
============================================================ */

const MAP_CONJ = {

  /* ==== Existing approved conjuncts ==== */
  "‡§ï‡•ç‡§ï":"Àú","‡§¶‡•ç‡§ó":"√™√Æ","‡§¶‡•ç‡§ò":"√™√≤","‡§¶‡•ç‡§¶":"¬®","‡§¶‡•ç‡§¨":"√™√¥","‡§¶‡•ç‡§≠":"√™B","‡§∑‡•ç‡§ü‡•ç‡§∞":"√†t√∂",

  /* ==== Complex clusters ==== */
  "‡§Ö‡§∏‡•ç‡§§‡§ø‡§§‡•ç‡§µ":"Ai√°q√ãv","‡§ï‡•É‡§§‡•ç‡§∞‡•ç‡§Ø":"‚Ñ¢√£X",
  "‡§ï‡•ç‡§∑‡•ç‡§ü‡•ç‡§∞‡§ø":"i√¢t√∂","‡§ï‡•ç‡§∑‡•ç‡§£‡§ø":"i√¢x","‡§ï‡•ç‡§∑‡•ç‡§™‡•ç‡§∞‡§ø":"i√¢pR","‡§ï‡•ç‡§∑‡•ç‡§Æ‡•ç‡§Ø‡§ø":"i√¢MX",
  "‡§ö‡§ø‡§§‡•ç‡§∞":"icZ","‡§ö‡§ø‡§®‡•ç‡§§":"icNq","‡§ö‡§ø‡§®‡•ç‡§§‡§æ":"icNqw",
  "‡§ú‡•ç‡§û‡•ç‡§§‡•ç‡§∞‡§ø":"i√•Z","‡§ú‡•ç‡§û‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√•~X","‡§ú‡•ç‡§û‡•ç‡§∏‡•ç‡§§‡•ç‡§∞‡§ø":"i√•√°Z",
  "‡§§‡•ç‡§∞‡§ø‡§∑‡•ç‡§ü":"iZ√†t","‡§¶‡§ø‡§ï‡•ç‡§∑":"id@","‡§¶‡•Ä‡§ï‡•ç‡§∑‡§ø‡§§":"dIi@q",
  "‡§¶‡•É‡§∑‡•ç‡§ü‡§ø":"d√∑i√†t",
  "‡§¶‡•ç‡§ß‡•ç‡§∞‡§ø":"i¬©R","‡§¶‡•ç‡§ß‡•ç‡§∞‡•ç‡§Ø‡§ø":"i¬©R√î","‡§∞‡•ç‡§∂‡•ç‡§§‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√ú√£X~","‡§∞‡•ç‡§∂‡•ç‡§ö‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√úcR√î~",

  "‡§ò‡•ç‡§®":"%n",

"‡§∞‡•ç‡§≤‡•ç‡§ï‡•ç‡§∞‡§ø":"i√òk√µ~","‡§∞‡•ç‡§≤‡•ç‡§™‡§ø":"i√òp~","‡§∞‡•ç‡§µ‡•ç‡§Ø‡§ø":"i√õX~","‡§∞‡•ç‡§∂‡§ø":"iS~","‡§∞‡•ç‡§∂‡•ç‡§ö‡§ø":"i√úc~","‡§∞‡•ç‡§∂‡•ç‡§∞‡§ø":"i‚Ä∞~","‡§∞‡•ç‡§∂‡•ç‡§∞‡•ç‡§Ø‡§ø":"i‚Ä∞√î~","‡§∞‡•ç‡§∑‡§ø":"i‚Ä†~","‡§∞‡•ç‡§∑‡•ç‡§ü‡§ø":"i√†t~","‡§∞‡•ç‡§∑‡•ç‡§ü‡•ç‡§∞‡§ø":"i√†t√∂~","‡§∞‡•ç‡§∑‡•ç‡§ü‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√†t√∂√î~","‡§∞‡•ç‡§∑‡•ç‡§ü‡•ç‡§∏‡•ç‡§§‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√†√®√°√£X~","‡§∞‡•ç‡§∑‡•ç‡§†‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√Ñ√∂√î~","‡§∞‡•ç‡§∑‡•ç‡§£‡§ø":"i√†x~","‡§∞‡•ç‡§∑‡•ç‡§§‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√†√£X~","‡§∞‡•ç‡§∏‡§ø":"is~",
"‡§∞‡•ç‡§∏‡•ç‡§§‡•ç‡§®‡•ç‡§Ø‡§ø":"i√°√ãNXs~","‡§∞‡•ç‡§∏‡•ç‡§™‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√°pR√î~","‡§∞‡•ç‡§§‡•ç‡§Æ‡•ç‡§Ø‡§ø":"i√ãMX~","‡§∞‡•ç‡§¶‡•ç‡§≠‡•ç‡§∞‡§ø":"i√™BR~","‡§∞‡•ç‡§™‡•ç‡§§‡•ç‡§∞‡§ø":"i√éZ~","‡§∞‡•ç‡§¨‡•ç‡§ß‡•ç‡§∞‡§ø":"i√ëDR~","‡§∞‡•ç‡§´‡•ç‡§∞‡•ç‡§Ø‡§ø":"iP√µ√î~",

  /* ==== r + i clusters (deduplicated) ==== */
  "‡§∞‡•ç‡§ï‡§ø":"ik~","‡§∞‡•ç‡§ï‡•ç‡§§‡§ø":"i√Ç~","‡§∞‡•ç‡§ï‡•ç‡§§‡•ç‡§∞‡§ø":"i√ÇR~","‡§∞‡•ç‡§ï‡•ç‡§§‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√ÇR√î~",
  "‡§∞‡•ç‡§ï‡•ç‡§∞‡§ø":"ik√µ~","‡§∞‡•ç‡§ï‡•ç‡§≤‡§ø":"i‚Ä∫~","‡§∞‡•ç‡§ï‡•ç‡§∑‡§ø":"i@~",
  "‡§∞‡•ç‡§ï‡•ç‡§∑‡•ç‡§ü‡•ç‡§∞‡§ø":"i√¢t√∂~","‡§∞‡•ç‡§ï‡•ç‡§∑‡•ç‡§ü‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√¢t√∂√î~",
  "‡§∞‡•ç‡§ï‡•ç‡§∑‡•ç‡§£‡§ø":"i√¢x~","‡§∞‡•ç‡§ï‡•ç‡§∑‡•ç‡§£‡•ç‡§Ø‡§ø":"i√¢&X~",

  "‡§∞‡•ç‡§ö‡§ø":"ic~","‡§∞‡•ç‡§ö‡•ç‡§õ‡§ø":"i√áC~","‡§∞‡•ç‡§ö‡•ç‡§Ø‡§ø":"i√áX~","‡§∞‡•ç‡§ö‡•ç‡§∞‡§ø":"icR~",

  "‡§∞‡•ç‡§ù‡§ø":"iJ~","‡§∞‡•ç‡§ù‡•ç‡§∞‡§ø":"iJR~",
  "‡§∞‡•ç‡§û‡§ø":"i\\~","‡§∞‡•ç‡§û‡•ç‡§ö‡§ø":"i√äc~",

  "‡§∞‡•ç‡§°‡§ø":"if~","‡§∞‡•ç‡§°‡•ç‡§ß‡§ø":"i√©D~","‡§∞‡•ç‡§°‡•ç‡§∞‡§ø":"if√∂~",

  "‡§∞‡•ç‡§£‡§ø":"ix~","‡§∞‡•ç‡§£‡•ç‡§ü‡§ø":"i&t~","‡§∞‡•ç‡§£‡•ç‡§°‡§ø":"i&f~",

  "‡§∞‡•ç‡§™‡§ø":"ip~","‡§∞‡•ç‡§™‡•ç‡§§‡§ø":"i√éq~","‡§∞‡•ç‡§™‡•ç‡§§‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√é√£X~","‡§∞‡•ç‡§™‡•ç‡§∞‡§ø":"ipR~",

  "‡§∞‡•ç‡§´‡§ø":"iP~","‡§∞‡•ç‡§´‡•ç‡§∞‡§ø":"iP√µ~",

  "‡§∏‡•É‡§∑‡•ç‡§ü‡§ø":"s√∑i√†t",
"‡§ú‡§É":"j√ö","‡§∞‡§É":"r√ö","‡§®‡§É":"n√ö","‡§ï‡•ç‡§∑‡•ç‡§Ø":"√¢X","‡§ú‡•ç‡§û‡§™‡•ç‡§§‡§ø‡§É":"zi√éq√ö","‡§ô‡•ç‡§ï‡•ç‡§∑‡•ç‡§µ":"√ß√´`√†v","‡§∑‡•ç‡§ü‡•ç‡§∞‡•ç‡§Ø":"√†t√∂√î","‡§≠‡•ç‡§∞‡§Ç‡§∂‡•ç‡§§‡•ç‡§∞":"BR<√úZ",

  /* ==== base conjuncts ==== */
  "‡§™‡•ç‡§∞":"pR","‡§§‡•ç‡§∞":"Z","‡§ú‡•ç‡§û":"z","‡§∂‡•ç‡§∞":"‚Ä∞",
  "‡§¶‡•ç‡§Ø":"¬¥","‡§¶‡•ç‡§Ø‡•Å":"¬¥u",
  "‡§∏‡•ç‡§§‡•ç‡§∞":"√°Z","‡§Æ‡•ç‡§®":"Mn","‡§ó‡•ç‡§®":"^n",
  "‡§ï‡•ç‡§§":"√Ç","‡§∏‡•ç‡§µ":"√°v","‡§ï‡•ç‡§∑":"@","‡§ó‡•ç‡§∞":"gR",

  /* ==== ‡§ë series ==== */
  "‡§ï‡•ç‡§§‡•â":"√Çw","‡§§‡•ç‡§∞‡•â":"Zw","‡§¶‡•ç‡§∞‡•â":"dRw","‡§ï‡•ç‡§∞‡•â":"k√µw","‡§ó‡•ç‡§∞‡•â":"gRw",
  "‡§™‡•ç‡§∞‡•â":"pRw","‡§¨‡•ç‡§∞‡•â":"bRw","‡§ß‡•ç‡§∞‡•â":"DRw","‡§∂‡•ç‡§∞‡•â":"‚Ä∞w",

  "‡§ï‡•â":"kw","‡§ñ‡•â":"Kw","‡§ó‡•â":"gw","‡§ò‡•â":"Gw","‡§ô‡•â":"|w",
  "‡§ö‡•â":"cw","‡§õ‡•â":"Cw","‡§ú‡•â":"jw","‡§ù‡•â":"Jw","‡§û‡•â":"\\w",

  "‡§ü‡•â":"tw","‡§†‡•â":"Tw","‡§°‡•â":"fw","‡§¢‡•â":"Fw","‡§£‡•â":"xw",
  "‡§§‡•â":"qw","‡§•‡•â":"Qw","‡§¶‡•â":"dw","‡§ß‡•â":"Dw","‡§®‡•â":"nw",

  "‡§™‡•â":"pw","‡§´‡•â":"Pw","‡§¨‡•â":"bw","‡§≠‡•â":"Bw","‡§Æ‡•â":"mw",
  "‡§Ø‡•â":"Xw","‡§∞‡•â":"rw","‡§≤‡•â":"lw","‡§µ‡•â":"vw",
  "‡§∂‡•â":"Sw","‡§∑‡•â":"‚Ä†w","‡§∏‡•â":"sw","‡§π‡•â":"hw",

  /* --- final --- */
  "‡§£‡•ç‡§Ø":"&X"
};


// ZWJ-variant conjuncts for Word-style sequences (e.g. ‡§§‡•ç‚Äç‡§∞, ‡§∏‡•ç‚Äç‡§µ)
const MAP_CONJ_ZWJ = {};
for (const key in MAP_CONJ) {
  if (key.includes("‡•ç")) {
    // Insert ZWJ (U+200D) after every halant
    const zwjKey = key.replace(/‡•ç/g, "‡•ç‚Äç");  // halant + ZWJ
    MAP_CONJ_ZWJ[zwjKey] = MAP_CONJ[key];
  }
}


/* ============================================================
   PART 5 ‚Äì WORD EXCEPTIONS (MAP_WORDS)
   Absolute top priority
============================================================ */
const MAP_WORDS = {
  "‡§§‡•ç‡§∞‡§ø‡§ï‡•Ç‡§ü":"iZkUt","‡§∞‡•Å":"{","‡§§‡•ç‡§∞‡§ø‡§™‡•É‡§∑‡•ç‡§†":"iZp√∑√Ñ","‡§§‡•ç‡§∞‡§ø‡§µ‡•á‡§£‡•Ä":"iZvyxI","‡§ï‡•ç‡§≤‡•ç‡§Ø‡•å":"‚Ä∫√îO","‡§∞‡•Ç":"}",
"‡§§‡•ç‡§∞‡§ø‡§∂‡•Ç‡§≤":"iZSUl","‡§§‡•ç‡§µ‡•ç‡§Ø":"√ã√õX","‡§ã‡§∑‡•Ä":"ÀÜ‚Ä†I","‡§∑‡•Ä":"‚Ä†I","‡§Æ‡•ç‡§∞":"mR","‡§∏‡•ç‡§§‡•ç‡§∞‡•à‡§£‡•ç‡§Ø":"√°ZY&X","‡§ï‡•ç‡§Ø":"#X","‡§£‡•ç‡§Ø":"&X","‡§¶‡•ç‡§≠‡•ç‡§∞":"√™BR","‡§ï‡•ç‡§∑‡•ç‡§Æ‡•ç‡§Ø":"√¢MX","‡§∏‡•ç‡§§‡•ç‡§∞‡•ç‡§Ø‡§É":"√°√£X√ö","‡§†‡•ç‡§Ø‡§ï‡•ç‡§∞":"T√îk√µ","‡§∞‡•ç‡§∑‡§ø":"i‚Ä†~",
  "‡§§‡•ç‡§∞‡§æ‡§∏‡§¶‡•Ä":"ZwsdI","‡§ú‡•ç‡§û‡§æ‡§®‡•á‡§∂‡•ç‡§µ‡§∞":"zwny√úvr","‡§ú‡•ç‡§û‡§æ‡§®‡§ï‡•ã‡§∂":"zwnkoS","‡§∞‡•ç‡§£":"x~","‡§∞‡•ç‡§£‡•ç‡§Ø":"&X~","‡§∞‡•ç‡§£‡•ç‡§µ":"&v~","‡§∞‡•ç‡§£‡•ç‡§Æ":"&m~","‡§∞‡•ç‡§£‡•ç‡§®":"&n~","‡§¶‡•ç‡§ò‡•ç‡§®‡•ç‡§Ø":"√™√≤√≥√î",
  "‡§∞‡•ç‡§£‡•ç‡§°":"&f~","‡§∞‡•ç‡§£‡•ç‡§ß":"&D~","‡§∞‡•ç‡§£‡•ç‡§ó":"&g~","‡§∞‡•ç‡§£‡•ç‡§ï":"&k~","‡§∞‡•ç‡§£‡•ç‡§†":"&T~","‡§∞‡•ç‡§£‡•ç‡§ü":"&t~","‡§∞‡•ç‡§£‡•ç‡§™":"&p~","‡§∞‡•ç‡§£‡•ç‡§≠":"&B~","‡§∞‡•ç‡§£‡•ç‡§∏":"&s~","‡§∞‡•ç‡§£‡•ç‡§Ø":"&X~",
  "‡§∞‡•ç‡§£‡•ç‡§∑":"&‚Ä†~","‡§∞‡•ç‡§£‡•ç‡§ú":"&j~","‡§∞‡•ç‡§£‡•ç‡§§":"&q~","‡§∞‡•ç‡§£‡•ç‡§Æ‡•ç‡§Ø":"&MX~","üî• ":"üî• ","‡§∞‡•ç‡§®‡•ç‡§Ø":"NX~","‡§∞‡•ç‡§Æ‡•ç‡§Ø":"MX~","‡§∞‡•ç‡§∏‡•ç‡§Ø":"√°X~","‡§∞‡•ç‡§§‡•ç‡§Ø":"√ãX~","‡§∞‡•ç‡§•‡•ç‡§Ø":"√åX~","‡§∞‡•ç‡§ú‡•ç‡§Ø":"√àX~","‡§∞‡•ç‡§ï‡•ç‡§Ø":"#X~","‡§∞‡•ç‡§µ‡•ç‡§Ø":"√õX~","‡§∞‡•ç‡§ò‡•ç‡§Ø":"%X~","‡§∞‡•ç‡§π‡•ç‡§Ø":"HX~",
  "‡§µ‡§ø‡§ú‡•ç‡§û‡§™‡•ç‡§§‡§ø":"ivzi√éq","‡§™‡•ç‡§∞‡§ú‡•ç‡§û‡§æ":"pRzw","‡§∏‡§Ç‡§ú‡•ç‡§û‡§æ":"s<zw",
  "‡§ï‡•ç‡§∑‡§∞‡§£":"@rx","‡§ï‡•ç‡§∑‡§§‡•ç‡§∞‡§ø‡§Ø":"@iZX","‡§ï‡•ç‡§∑‡§Æ‡§æ‡§∂‡•Ä‡§≤":"@mwSIl",
  "‡§â‡§§‡•ç‡§ï‡•É‡§∑‡•ç‡§ü":"a√ã‚Ñ¢√†t","‡§ï‡•É‡§∑‡•ç‡§£":"‚Ñ¢√†x","‡§Ö‡§ï‡•ç‡§∑‡§∞":"A@r",
  "‡§∂‡•ç‡§∞‡§µ‡§£":"‚Ä∞vx","‡§∂‡•ç‡§∞‡•á‡§Ø‡§æ":"‚Ä∞yXw","‡§∂‡•ç‡§∞‡§Æ‡§ø‡§ï":"‚Ä∞imk",
  "‡§∂‡•ç‡§∞‡•á‡§Ø‡§∏‡•ç‡§ï‡§∞":"‚Ä∞yX√°kr","‡§∂‡•ç‡§∞‡§¶‡•ç‡§ß‡§æ":"‚Ä∞¬©w",
  "‡§µ‡§ø‡§¶‡•ç‡§Ø‡•Å‡§§":"iv¬¥uq","‡§®‡•ç‡§Ø‡§æ‡§Ø‡§æ‡§≤‡§Ø":"NXwXwlX","‡§â‡§¶‡•ç‡§Ø‡§æ‡§®":"a¬¥wn","‡§¶‡•ç‡§Ø‡•Å‡§§‡§ø":"¬¥uiq",
  "‡§Ö‡§ß‡•ç‡§Ø‡§æ‡§§‡•ç‡§Æ":"A√çXw√ãm","‡§ß‡•ç‡§Ø":"√çX","‡§ß‡•ç‡§Ø‡§æ‡§®":"√çXwn",
  "‡§Ö‡§ß‡•ç‡§Ø‡§Ø‡§®":"A√çXXn","‡§Ö‡§ß‡•ç‡§Ø‡§æ‡§Ø":"A√çXwX","‡§¶‡•ç‡§ò‡•ç‡§®":"√™√≤√≥","‡§¶‡•ç‡§ó‡•ç‡§ß":"√™√Æ`D",
  "‡§Æ‡§ß‡•ç‡§Ø‡§™‡•ç‡§∞‡§¶‡•á‡§∂":"m√çXpRdyS","‡§∏‡§æ‡§ß‡•ç‡§Ø":"sw√çX","‡§§‡•ç‡§µ":"√ãv",
  "‡§∏‡§Ç‡§∏‡•ç‡§ï‡•É‡§§‡§ø‡§§‡•ç‡§µ":"s<√°‚Ñ¢iq√ãv","‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§§‡•ç‡§µ":"√õXi√Ç√ãv","‡§∏‡•ç‡§§‡•ç‡§∞‡•Ä‡§§‡•ç‡§µ":"√°ZI√ãv",
  "‡§™‡§µ‡§ø‡§§‡•ç‡§∞‡§§‡•ç‡§µ":"pivZ√ãv","‡§Ü‡§§‡•ç‡§Æ‡§§‡•ç‡§µ":"Aw√ãm√ãv",
  "‡§∂‡•ç‡§µ":"√úv","‡§∂‡•ç‡§µ‡§∏‡§®":"√úvsn","‡§∂‡•ç‡§µ‡§æ‡§∏":"√úvws","‡§∂‡•ç‡§µ‡•á‡§§":"√úvyq","‡§§‡§É":"q√ö",
  "‡§∂‡•ç‡§µ‡§æ‡§®":"√úvwn","‡§∂‡•ç‡§µ‡•á‡§ö‡•ç‡§õ‡§æ":"√úvy√áCw",
  "‡§Ö‡§π‡•ç‡§®‡§ø‡§ï‡§æ":"AiHnkw","‡§™‡•ç‡§∞‡§π‡•ç‡§£":"pRHx","‡§¶‡§π‡•ç‡§®‡§ø":"diHn","‡§π‡§ø‡§Æ‡§æ‡§≤‡§Ø":"ihmwlX",
  "‡§â‡§®‡•ç‡§Æ‡•á‡§∑":"aNmy‚Ä†","‡§â‡§®‡•ç‡§Æ‡§æ‡§¶":"aNmwd","‡§¨‡•ç‡§∞‡§π‡•ç‡§Æ":"bRHm","‡§¨‡•ç‡§∞‡§π‡•ç‡§Æ‡§æ":"bRHmw",
  "‡§∏‡•ç‡§§‡•ç‡§∞":"√°Z","‡§∏‡•ç‡§§‡•ç‡§∞‡•Ä":"√°ZI","‡§∏‡•ç‡§§‡•ç‡§∞‡•ã‡§§":"√°Zoq","‡§∏‡•ç‡§§‡•ç‡§∞‡•à‡§£":"√°ZYx",
  "‡§∏‡•ç‡§§‡•ç‡§∞‡•à‡§£‡§§‡§æ":"√°ZYxqw","‡§∏‡•ç‡§§‡•ç‡§∞‡•ã‡§§‡§∏‡•ç‡§µ‡§∞":"√°Zoq√°vr",
  "‡§ö‡§Æ‡§§‡•ç‡§ï‡§æ‡§∞‡§ø‡§ï:":"cm√ãkwirk:","‡§ö‡§ø‡§®‡•ç‡§Æ‡§Ø":"icNmX","‡§Æ‡§®‡§®":"mnn",
  "‡§Ö‡§Æ‡•ç‡§®‡§æ‡§Ø":"AMnwX","‡§®‡§ø‡§Æ‡•ç‡§®":"inMn","‡§∏‡•ç‡§Æ‡§∞‡§£":"√°mrx",
  "‡§ß‡§æ‡§§‡•ç‡§µ‡§∞‡•ç‡§•":"Dw√ãvQ~","‡§∏‡§Ç‡§Ø‡•ã‡§ú‡§®":"s<Xojn",
  "‡§¶‡•Å‡§ó‡•ç‡§ß‡§ó‡•ç‡§®":"du^D^n","‡§∞‡§æ‡§ó‡•ç‡§®‡•ç‡§Ø":"rw^NX","‡§Ö‡§ó‡•ç‡§®‡§ø‡§¶‡•á‡§µ":"Ai^ndyv","‡§Ö‡§ó‡•ç‡§®‡§ø‡§ï‡•Å‡§Ç‡§°":"Ai^nku<f",
  "‡§â‡§ï‡•ç‡§§":"a√Ç","‡§≠‡•Å‡§ï‡•ç‡§§":"Bu√Ç","‡§Ø‡•Å‡§ï‡•ç‡§§":"Xu√Ç","‡§¶‡•É‡§∑‡•ç‡§ü":"d√∑√†t","‡§≠‡§ï‡•ç‡§§‡§ø":"Bi√Ç",
  "‡§∏‡•ç‡§µ‡§∏‡•ç‡§§‡§ø‡§™‡•ç‡§∞‡§ú‡§æ‡§≠‡•ç‡§Ø‡§É":"√°vi√°qpRjw√íX√ö",
  "‡§™‡§∞‡§ø‡§™‡§æ‡§≤‡§Ø‡§®‡•ç‡§§‡§æ‡§Ç":"pirpwlXNqw<","‡§®‡•ç‡§Ø‡§æ‡§Ø‡•á‡§®":"NXwXyn","‡§Æ‡§æ‡§∞‡•ç‡§ó‡•á‡§£":"mwgy~x",
  "‡§ó‡•ã‡§¨‡•ç‡§∞‡§æ‡§π‡•ç‡§Æ‡§£‡•á‡§≠‡•ç‡§Ø‡§É":"gobRwHmxy√íX√ö","‡§∂‡•Å‡§≠‡§Æ‡§∏‡•ç‡§§‡•Å":"SuBm√°qu","‡§®‡§ø‡§§‡•ç‡§Ø‡§Ç":"in√ãX<",
  "‡§≤‡•ã‡§ï‡§æ‡§É":"lokw√ö","‡§∏‡§Æ‡§∏‡•ç‡§§‡§æ‡§É":"sm√°qw√ö","‡§∏‡•Å‡§ñ‡§ø‡§®‡•ã":"suiKno","‡§≠‡§µ‡§®‡•ç‡§§‡•Å":"BvNqu","‡§∞‡•ç‡§∏‡•ç‡§ï‡•ç‡§§‡•ç‡§∞‡§ø":"i√°√ÇR~","‡§∞‡•ç‡§∏‡•ç‡§ï‡•ç‡§∞‡•ç‡§Ø‡§ø":"i√°k√µ√î~","‡§ï‡•ç‡§∑‡•ç‡§Æ":"√¢m","‡§∞‡•ç‡§≠‡•ç‡§∞‡•ç‡§Ø‡§ø":"iBR√î~","‡§∞‡•ç‡§Æ‡•ç‡§Ø‡•ç‡§∞‡§ø":"iMXR~","‡§∞‡•ç‡§£‡•ç‡§°‡•ç‡§∞‡§ø":"i&f√∂~","‡§∞‡•ç‡§∏‡•ç‡§§‡•ç‡§∞‡•ç‡§Æ‡§ø":"i√°√£m~","‡§∞‡•ç‡§∏‡•ç‡§ï‡•ç‡§≤‡•ç‡§Ø‡§ø":"i√°‚Ä∫√î~","‡§∞‡•ç‡§∏‡•ç‡§ï‡•ç‡§®‡•ç‡§∞‡§ø":"i√°#nR~","‡§∞‡•ç‡§∏‡•ç‡§§‡•ç‡§∞‡•ç‡§µ‡§ø":"i√°√£v~","‡§∞‡•ç‡§ï‡•ç‡§∞‡•ç‡§Ø‡§ø":"ik√µ√î~","‡§∞‡•ç‡§ï‡•ç‡§∑‡•ç‡§∞‡§ø":"i√¢r~","‡§∞‡•ç‡§∂‡•ç‡§ï‡•ç‡§∞‡§ø":"i√úk√µ~","‡§∞‡•ç‡§∂‡•ç‡§§‡•ç‡§∞‡§ø":"i√úZ~","‡§∞‡•ç‡§∏‡•ç‡§™‡•ç‡§∞‡§ø":"i√°pR~","‡§°‡•â‡§ï‡•ç‡§ü‡§∞":"f‡•â#tr","‡§∏‡•ç‡§∞":"sR","‡§ï‡•ç‡§≤":"‚Ä∫"
};

/* ============================================================
   PART 6 ‚Äì DERIVED HELPER SETS & CONSTANTS
============================================================ */
const WORD_KEYS = Object.keys(MAP_WORDS).sort((a,b)=>b.length - a.length);
const CONJ_KEYS = Object.keys(MAP_CONJ).sort((a,b)=>b.length - a.length);
const CONJ_KEYS_ZWJ = Object.keys(MAP_CONJ_ZWJ).sort((a,b)=>b.length - a.length);


const CONJ_VALUES = new Set(Object.values(MAP_CONJ));
const HALF_VALUES = new Set([
  ...Object.values(MAP_HALFA),
  ...Object.values(MAP_HALFB)
]);

const MAX_CONJ_LEN = Math.max(...Array.from(CONJ_VALUES, v => v.length));
const MAX_HALF_LEN = Math.max(...Array.from(HALF_VALUES, v => v.length));

const SIMPLE_CONS_CHARS = new Set([
  "k","K","g","G","|","c","C","j","J","\\",
  "t","T","f","F","x","q","Q","d","D","n",
  "p","P","b","B","m","X","r","l","v","S",
  "‚Ä†","s","h"
]);

function isDevaConsonant(ch) {
  return /[‡§ï-‡§π‡•ò-‡•ô‡•ö‡•õ‡•ú‡•ù‡•û‡•ü]/.test(ch);
}

// Look ahead from the halant to see if ANY consonant appears
// (ignoring ZWJ/ZWNJ and matras/signs)
function hasNextConsonantAfterHalant(text, halantIndex) {
  for (let j = halantIndex + 1; j < text.length; j++) {
    const ch = text[j];

    // ignore ZWJ/ZWNJ
    if (ch === "\u200c" || ch === "\u200d") continue;

    if (isDevaConsonant(ch)) return true;

    // if non-Devanagari, stop scan
    if (!/[\u0900-\u097F]/.test(ch)) return false;

    // matras/signs: continue scanning
  }
  return false;
}

/* ============================================================
   PART 7 ‚Äì i-SWAP (rules a, b, c)
============================================================ */
function swapI(text) {
  let arr = text.split("");

  for (let i = 0; i < arr.length; i++) {

    if (arr[i] !== "i") continue;

    let posC = i - 1;
    if (posC < 0) continue;

    // do not cross whitespace
    if (/\s/.test(arr[posC])) continue;

    let moved = false;

    // Rule (c): If just after conjunct ‚Üí move before conjunct
    for (let L = MAX_CONJ_LEN; L >= 1; L--) {
      const start = posC - L + 1;
      if (start < 0) continue;

      const cand = arr.slice(start, posC + 1).join("");
      if (CONJ_VALUES.has(cand)) {
        arr.splice(i, 1);
        arr.splice(start, 0, "i");
        i = start + 1;
        moved = true;
        break;
      }
    }
    if (moved) continue;

    // Now must be consonant or skip
    if (!SIMPLE_CONS_CHARS.has(arr[posC])) continue;

    // Rule (b): look for half block before consonant
    let clusterStart = posC;
    const halfEnd = posC - 1;

    if (halfEnd >= 0) {
      for (let L = MAX_HALF_LEN; L >= 1; L--) {
        const start = halfEnd - L + 1;
        if (start < 0) continue;

        const cand = arr.slice(start, halfEnd + 1).join("");
        if (HALF_VALUES.has(cand)) {
          clusterStart = start;
          break;
        }
      }
    }

    // Rule (a/b): move i before clusterStart
    arr.splice(i, 1);
    arr.splice(clusterStart, 0, "i");
    i = clusterStart + 1;
  }

  return arr.join("");
}

/* ============================================================
   PART 8 ‚Äì REPH FIX (r` ‚Üí ~ position) ‚Äî Now respects badi-ee "I"
============================================================ */

function fixReph(text) {
  let arr = text.split("");
  let i = 0;

  const HALF_CONS = new Set([
    "#","$","^","%","√ß","√á","C","√à","√â","√ä","√®","T`","√©","F",
    "&","√ã","√å","√ç","N","√é","√ú","√°","√†","√è","√ë","M","√í","√ò","√õ","r`"
  ]);

  const FULL_CONS = new Set([
    "K","g","G","|","c","C","j","J","\\","t","T","‡§°","f","F",
    "x","q","Q","d","D","n","p","P","b","B","m","X","r",
    "l","v","S","‚Ä†","s","h","√π"
  ]);

  const MATRA_AFTER = new Set(["<",">","w","I","u","U","y","Y","o","O","√∑"]);

  while (i < arr.length - 1) {

    if (arr[i] === "r" && arr[i + 1] === "`") {

      /* ---------- CLAUSE 1 (i + FULL + optional MATRA) ---------- */
      if (arr[i + 2] === "i" && FULL_CONS.has(arr[i + 3])) {

        // start scanning immediately after FULL consonant
        let scan = i + 4;
        let matraIdx = -1;

        if (scan < arr.length && MATRA_AFTER.has(arr[scan])) {
          matraIdx = scan;
        }

        // remove r`
        arr.splice(i, 2);

        if (matraIdx !== -1) {
          // adjust index after removal
          matraIdx -= 2;

          // insert AFTER matra
          arr.splice(matraIdx + 1, 0, "~");
        } else {
          // no matra ‚Üí after FULL consonant
          arr.splice(i + 1, 0, "~");
        }
        continue;
      }

      /* ---------- CLAUSE 3: HALF ‚Üí FULL ‚Üí MATRA ---------- */
      let halfIdx = i + 2;
      let fullIdx = halfIdx + 1;
      let matraIdx = fullIdx + 1;

      if (
        HALF_CONS.has(arr[halfIdx]) &&
        FULL_CONS.has(arr[fullIdx]) &&
        MATRA_AFTER.has(arr[matraIdx])
      ) {
        arr.splice(i, 2);
        matraIdx -= 2;
        arr.splice(matraIdx + 1, 0, "~");
        continue;
      }

      /* ---------- CLAUSE 2: FULL consonant ---------- */
      if (FULL_CONS.has(arr[i + 2])) {
        arr.splice(i, 2);
        arr.splice(i + 1, 0, "~");
        continue;
      }

      /* ---------- fallback ---------- */
      arr.splice(i, 2, "~");
      continue;
    }

    i++;
  }

  return arr.join("");
}



/* ============================================================
   PART 9 ‚Äì FULL UNICODE ‚Üí AMAR ENGINE WITH PRIORITY
   Priority:
   1. WORDS (MAP_WORDS)
   2. CONJUNCTS (MAP_CONJ)
   3. HALF A (if ANY consonant appears after halant)
   4. HALF B (if NO consonant after halant)
   5. LETTERS
   then apply swapI + fixReph
============================================================ */
function fullUnicodeToAmar(text) {
  let out = "";
  let i = 0;

  outerLoop:
  while (i < text.length) {

    // 1. WORD EXCEPTIONS
    for (const w of WORD_KEYS) {
      if (text.startsWith(w, i)) {
        out += MAP_WORDS[w];
        i += w.length;
        continue outerLoop;
      }
    }

    // 2. CONJUNCTS (normal)
    for (const cj of CONJ_KEYS) {
      if (text.startsWith(cj, i)) {
        out += MAP_CONJ[cj];
        i += cj.length;
        continue outerLoop;
      }
    }

    // 2b. CONJUNCTS with ZWJ (e.g. ‡§§‡•ç‚Äç‡§∞, ‡§∏‡•ç‚Äç‡§µ)
    for (const cj of CONJ_KEYS_ZWJ) {
      if (text.startsWith(cj, i)) {
        out += MAP_CONJ_ZWJ[cj];
        i += cj.length;
        continue outerLoop;
      }
    }

    const ch = text[i];
    const next = text[i+1];

    // Skip ZWJ/ZWNJ in output
    if (ch === "\u200c" || ch === "\u200d") {
      i++;
      continue;
    }


    // 3 & 4. HALF A / HALF B with "any consonant after halant" rule
    if (next === "‡•ç") {
      const halfKey = ch + "‡•ç";
      const hasCons = hasNextConsonantAfterHalant(text, i + 1);

      // If any consonant later ‚Üí prefer HALF A when present
      if (hasCons && MAP_HALFA[halfKey]) {
        out += MAP_HALFA[halfKey];
        i += 2;
        continue;
      }

      // If no consonant later ‚Üí prefer HALF B when present
      if (!hasCons && MAP_HALFB[halfKey]) {
        out += MAP_HALFB[halfKey];
        i += 2;
        continue;
      }

      // Fallbacks
      if (MAP_HALFA[halfKey]) {
        out += MAP_HALFA[halfKey];
        i += 2;
        continue;
      }
      if (MAP_HALFB[halfKey]) {
        out += MAP_HALFB[halfKey];
        i += 2;
        continue;
      }
    }

    // 5. SIMPLE LETTER
    if (MAP_LETTERS[ch] !== undefined) {
      out += MAP_LETTERS[ch];
    } else {
      out += ch;
    }

    i++;
  }

  // apply i-swap and reph after mapping
  out = swapI(out);
  out = fixReph(out);
  return out;
}




/* ============================================================
   PART 10 ‚Äì AMAR ‚Üí UNICODE REVERSE (best-effort)
============================================================ */
let MASTER_MAP = {};
for (const k in MAP_LETTERS) MASTER_MAP[k] = MAP_LETTERS[k];
for (const k in MAP_HALFB)   MASTER_MAP[k] = MAP_HALFB[k];
for (const k in MAP_HALFA)   MASTER_MAP[k] = MAP_HALFA[k];
for (const k in MAP_CONJ)    MASTER_MAP[k] = MAP_CONJ[k];
for (const k in MAP_WORDS)   MASTER_MAP[k] = MAP_WORDS[k];

let REVERSE_MAP = {};
for (const k in MASTER_MAP) {
  const v = MASTER_MAP[k];
  if (!REVERSE_MAP[v]) REVERSE_MAP[v] = k;
}
const REVERSE_KEYS = Object.keys(REVERSE_MAP).sort((a,b)=>b.length - a.length);

function amarToUnicode(text) {
  let out = "";
  let i = 0;
  while (i < text.length) {
    let matched = false;
    for (const key of REVERSE_KEYS) {
      if (text.startsWith(key, i)) {
        out += REVERSE_MAP[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (!matched) {
      out += text[i];
      i++;
    }
  }
  return out;
}

/* ============================================================
   PART 11 ‚Äì UI HANDLERS
============================================================ */
function handleUnicodeToAmar() {
  const u = document.getElementById("unicodeInput").value;
  const a = fullUnicodeToAmar(u);
  document.getElementById("amarOutput").value = a;
}

function handleAmarToUnicode() {
  const a = document.getElementById("amarOutput").value;
  const u = amarToUnicode(a);
  document.getElementById("unicodeInput").value = u;
}

function copyAmar() {
  const box = document.getElementById("amarOutput");
  box.select();
  document.execCommand("copy");
}

/* ============================================================
   PART 12 ‚Äì DOCX: Unicode ‚Üí Amar (keep structure)
============================================================ */
function xmlEscape(str) {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}


// DOCX converter using XML DOM (keeps formatting, solves corruption issues)
async function convertDocx() {
  const fileInput = document.getElementById("docxFile");
  if (!fileInput || !fileInput.files.length) {
    alert("Please choose a DOCX file.");
    return;
  }

  const file = fileInput.files[0];

  try {
    // 1) Read DOCX as ArrayBuffer and load with JSZip
    const arrayBuffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);

    // 2) Get word/document.xml
    const docFile = zip.file("word/document.xml");
    if (!docFile) {
      alert("This file does not look like a valid DOCX (word/document.xml missing).");
      return;
    }

    // 3) Read document.xml as UTF-8 string
    const xmlString = await docFile.async("string");

    // 4) Parse XML using DOMParser (much safer than regex)
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "application/xml");

    // Check for parse errors
    if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
      console.error("XML parse error:", xmlDoc.getElementsByTagName("parsererror")[0]);
      alert("Error reading DOCX XML structure.");
      return;
    }

    // 5) Get all <w:t> nodes (word text runs)
    const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    let textNodes = xmlDoc.getElementsByTagNameNS(W_NS, "t");
    if (!textNodes || textNodes.length === 0) {
      // Fallback if namespace lookup fails
      textNodes = xmlDoc.getElementsByTagName("w:t");
    }

    // 6) Convert text content of each node using your Unicode ‚Üí Amar converter
    for (let i = 0; i < textNodes.length; i++) {
      const node = textNodes[i];
      const original = node.textContent || "";
      
const converted = fullUnicodeToAmar(original);
node.textContent = converted;

// Insert <w:rPr><w:rFonts...>AmrHindi</w:rPr> before <w:t>
const runNode = node.parentNode; // <w:r>

if (runNode) {
    // Check if rPr already exists
    let rPr = runNode.getElementsByTagNameNS(W_NS, "rPr")[0];

    // If missing, create it
    if (!rPr) {
        rPr = xmlDoc.createElementNS(W_NS, "w:rPr");
        runNode.insertBefore(rPr, node); // insert before <w:t>
    }

    // Create rFonts
    let rFonts = xmlDoc.createElementNS(W_NS, "w:rFonts");
    rFonts.setAttribute("w:ascii", "AmrHindi");
    rFonts.setAttribute("w:hAnsi", "AmrHindi");
    rFonts.setAttribute("w:cs", "AmrHindi");

    // Append inside <w:rPr>
    rPr.appendChild(rFonts);
}


      node.textContent = converted;  // DOM will handle escaping
    }




    // 7) Serialize XML back to string
    const serializer = new XMLSerializer();
    const newXmlString = serializer.serializeToString(xmlDoc);

    // 8) Write the updated XML back into the zip
    zip.file("word/document.xml", newXmlString);

    // 9) Generate new DOCX blob
    const outBlob = await zip.generateAsync({
      type: "blob",
      mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    });

    // 10) Timestamped filename
    const ts = new Date().toISOString().replace(/[^\d]/g, "").slice(0,14);
    const outName = file.name.replace(/\.docx$/i, "") + "_amar_" + ts + ".docx";

    // 11) Download
    saveAs(outBlob, outName);
    alert("DOCX converted successfully.");

  } catch (err) {
    console.error("DOCX conversion error:", err);
    alert("Error converting DOCX. The file may be protected or not a standard DOCX.");
  }
}

</script>

<div id="kgFooter">
  Copyright@2025 by KG & NB! This module cannot be used commercially and without permission.
</div>

<style>
#kgFooter {
    position: fixed;
    bottom: 10px;
    right: 10px;
    font-size: 11px;
    font-family: Arial, sans-serif;
    color: #666;
    background: rgba(255,255,255,0.7);
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid #ddd;
    pointer-events: none; /* prevents clicks */
}
</style>


</body>
</html>





